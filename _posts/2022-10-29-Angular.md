# First stab at Angular

## Points to get started

* Angular is a single page application (SPA) web framework, including:
	* a browser-based runtime
	* Dev-time toolchain: Typescript compiler, bundlers, dependency management
	* Source is structured in a componenting system; component-oriented architecture
* AngularJS was a first iteration, superceded by Angular later - total rewrite, with no meaningful migration path
* Angular is written and built/compiled:
	* Text is in TypeScript, which compiles into Javascript
	* ES6 (Ecmascript 6)
	* Javascript is bundled into web-shippable JS files with Webpack (a _bundler_)
* Dev-time functionality is provided by nodejs:
	* Package & dependency management with npm tooling


## Javascript getting started bits

* `var` declarations in JS are "hoisted" - ie. deemed to have been at the top of their scope (global scope or function scope; not control-flow blocks (`if`, `for`, `while`, ...)).
* `let` is an ES6 solution to `var` weirdness
	* No hoisting
	* Declarable in all blocks, they get block scope
	* Names are re-useable in an inner scope
	* If you `let` a variable in a block that is also `let` in an outer block, but use it in the block before it's letted, you get a "used before inited" failure; ie. if you're going to reuse a name in a block, the outer-scope version is not available in that block:
		```language=js
let a = 6

if (true) {
	console.log("inside: " + a); // Boom!
	let a = 10;
}
```
* const is an ES6 thing; works as you'd expect.

### Function parameters
* No overriding:
	* If you call a JS function with fewer parms than in the signature, the remainder get undefined.
	* More parms, the overflow gets ignored.	
	* Replace a function with a new one, it just replaces.
	* All args are available in an `arguments` magic var, which is a dict of `{'0': "arg1 val", '1': "arg2 val"}`
	* Can specify unspecified args with `...argname` as the last parm - gives an iterable object
* String interpolation: String constant uses \` instead of ", and then use JS values with ${someVar}
* Dict initialisation shorthand for js objects in ES6 - doing `{Key1, Key2}` uses `Key1` and `Key2`'s values and names to initialised the dict; ie. `{Key1: Key1, Key2: Key2}`
* Spread operator does an unpack: 
```language=javascript
function three(a, b, c) {
	console.log(`${a} ${b} ${c}`);
}

> three(...a)
1 2 3
```
	* Used to clone arrays, cuz `a = [1]; b = a` does a refcopy
	* Also works with dicts: `c = {...{a: 1, b: 2}, ...{c: 3, d: 4}}`

### For loops
* For loops.  Given `a = [6, 7, 8, 9];`:
  * `for (let inx = 0; inx < a.length; index ++) { /* stuff */ }` - note array.length
  * `for (let inx in a) { /* stuff with a[inx] */ }` - `a` just takes on vals of the index; for dict-type objects it gives you keys, for arrays it gives you inxes
  * `for (let vals of a) { /* stuff with a */ }` - iterates over an iterable object (so arrays; dict-types aren't iterable). ES6 only


### Object properties
 * Properties of objects in JS
 	* It's bonkers and very evolved.
 	* Props can be "own" (ie. not "inherited" (from __proto__)), enumerable or string/symbol.
 		* the "in" operator works for all properties regardless
 		* `for (let a in|of b)` only gives you enumerable (both own & inherited)
 		* `obj.hasOwnProperty` and `obj.propertyIsEnumerable` give info

### JS inheritance
 * Prototype inheritance vs. class-based inheritance
 	* ES6 classes are just syntactical sugar over traditional JS prototyping
 	* All objects have a `__proto__` member, which is another object.
 	* When referencing an object property, it checks:
 		* The object
 		* `obj.__proto__`
 		* `obj.__proto__.__proto__`
 		* ... until the parent `__proto__` is null.
 	* Objects can have function properties. Call a function via the object sets the `this` pointer.
 	* A function can be a constructor: a standalone function which sets values on a `this` pointer. Calling such a function with the `new` operator:
 		* Creates a new object,
 		* Sets its `__proto__` to the `prototype` property of the constructor
 		* *Note:* all functions have a `prototype` property set to `{constructor: func}` by default; so, all functions are implicitly constructors even though they're not necessarily used that way.
 		* The `prototype.constructor` property above is inited to the function reference
 	* Can set methods by setting attribs on the prototype to function pointers
 ```language=javascript
 function Thingy() {}
 Thingy.prototype.getColour = () => {return this.colour;}
 Thingy.prototype.colour = "blue"

 a = new Thingy(); // Create empty object; set __proto__ to Thingy.prototype
 a.getColour(); // returns "blue" cuz a.__proto__ == Thingy.prototype
 a.colour = "red";
 a.getColour(); // returns "red"
 delete a.colour;
 a.getColour(); // "blue"
 ```
 Identical to:
 ```language=javascript
 class Thingy {
 	constructor() {}
 	function getColour() {return this.colour;}
 }
 Thingy.prototype.colour = "blue" // Rather set this in the constructor, though
 // ...
 ```
 ...all the way down to `typeof(Thingy) == function`

### Classes
* Classes are new in ES6. Prior, had the old JS class prototype weirdness.
* Class instances have dynamic attribs: 
	```language=javascript
class Dog {
	Save() { // Not yet sure about best practise for method names; this looks ick
		console.log("Dog saved: " + this.name + "( colour: " + this.colour + ")");
	}
}

milly = new Dog();
milly.name = "Milly";
milly.colour = "Brown and white";

milly.Save();
```
* Note creation w/ `new`
* constructors declared with `constructor` keyword: ```
class Dog {
	constructor(name, colour) {
		this.name = name;
		this.colour = colour;
	}
}
```
* Constructors are inherited if not redeclared in the subclass (duh cuz they're on the prototype)
* functions declared in the class are created as properties of the `MyClass.prototype`
* If the subclass implements a constructor, have to call superclass constructor w/ `super(...)` before referencing `this` or returning

### Anonymous functions

* function () {...} // this is bound at function invocation time
* () => {...} // this is bound at function creation time
* () => 10; // no braces if it's just an expression; python: a = lambda : 10

### This binding

* On function invocation, a new Local Execution Context is created w/ bunches of info, include the inited `this` value; determined based on these rules:
* *Default binding:* Called from top-level context (outside of an object call); `this` is set to the global context, and has access to all globals. In strict mode, it's `undefined`
* *Implicit binding:* Called in context of object - `myobj.foo()`.  This works no matter how the function is added as a property to the obj - at declaration time in a class, or later via assigning an anonymous function. `this` is calculated at invocation time.
* *Explicit binding:* Set explicitly. For `function foo() {console.log(this);}`, do `foo.call(obj)` Can also use:
	* `foo.apply([obj])` - like `call`, but args in an array
	* `foo.bind(obj)` - creates a closure with some parms already set, including the `this` from the first arg.
* *new binding:* When calling a constructor. Creates a new obj and passes it as `this`; `prototype` from func set as `__proto__` on the new object.
* *=> :* arrow funcs create a closure with `this` fixed as the `this` of the scope where the function was created.

### Misc stuff

* Array objects have a load of utility things on them, like `filter` (takes a lambda), `map` (ditto), `forEach` (like `map` but void return), ...
* The Object (which is a constructor; ie. a function) has a load of utility stuff for objects on it, like 
	* `Object.keys(obj)` - returns an array of enumerable keys
	* `Object.values(obj)` - as you'd expect
* Destructuring = unpacking:
	* `[a, b, c] = [1, 2, 3]`
	* `{c, a, b} = {a: 1, b: 2, c: 3} // Sorts out the order`
	* `[a1, b1] = [b1, a1] // Swapsies!`
	* `function doStuff(a, b, [c, d, e], f, g) {...}`, then `doStuff(1, 2, my3ElemArr, 11, 12)`
