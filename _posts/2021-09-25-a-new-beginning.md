---
A new beginning: an SRE learning project
---

## The Big Hairy-Arsed Goal

While I did a few months in a coding role in late 2019, it's still been a long time since I was a full-time developer working on a team. It seems such a pity to have all those skills stay dormant, becoming more and more out of date, and so I'm going to spend some time refreshing them.

I'm going to go through a full development cycle, creating an app from scratch, with a goal of refreshing and learning all of the various tasks. My goals are to:
1. Build just enough code and UI to demonstrate a full, commercial-grade application
1. Learn infrastructure-as-code at some depth en route:
  * An API-first, tenanted microservice
  * A simple web front-end, served by a CDN
  * A backing database to read from and write to, with appropriate network and authentication security
  * Some element of serverless code; maybe I'll refactor the API into this layer.
  * A data pipeline to demonstrate an event-based system. Events to be generated by the back-end of my application, and read by some mickey-mouse thing sitting in another VPC (virtual private cloud); appropriate security (encryption in transit, authentication to access the event pipeline).
  * Observability of all systems, gathering of the telemetry and dashboarding to analyse and monitor performance. 
1. Learn modern automated testing strategies: 
  * Unit tests, integration tests as part of the build
  * System tests as part of the deployment process
  * Automatic creation of new environments and testing of them as part of the build - locally and cloud based
1. Start small and refactor as the application gets larger

Clearly this is a lot of work! It will be taking me quite a while, and it's highly likely that I'll get fed up and stop before I'm finished.

Regardless, I'll be doing a blog post for each chunk of work that I do on it, mainly to document for myself what I did and why, but also possibly to generate some interest from other people who regret the waning of their technical skillset.

## Intermediate Goals

Breaking this down into more manageable chunks, I think it makes sense to go for user-visible chunks of functionality, delivering code regularly and as early as possible.  Thus:

| --------- |
| V1.0 | As a user, I can see a welcome page | A simple UI with an API-driven back end vdisplaying some data. Automated CI/CD and testing, infra-as-code deployment |
| V1.1 | As an SRE, I can see the events of what happened in the application | deploy, page load events & instrumentation |
| V2.0 | As a user, I can log in | A user account with a password - Auth0 integration, concept of tenancy in the app |
| V3.0 | As a user, I can capture a todo item and see my list of todo items. | Database driven; read and write. Appropriate security and authentication in the infrastructure |
| V3.1 | As an SRE, I can see a dashboard of the application load and database performance |
| V4.0 | As a user, I can create a new account. | User account creation |
| V4.1 | As a user, the application is available even when many users are using it | introduce elastic scaling of compute and database |
| V5.0 | As a user, I can reset my password. | Password reset |
| V6.0 | As an admin user, I can view and delete accounts | Permissions |
| V7.0 | Something event driven! |

## Project Management

I need to figure out how I'm going to manage this project. I think I'll run it as a little kanban team of one; my available time doesn't really allow for timeboxed sprints. I'll be using the GitHub project tools because it's already integrated with the source control that way.

Given I've spent thirteen years as a product guy I'll have to ensure that the stories are well written with clear definitions of done, etc - it would just be embarrassing otherwise!

The big question is mono-repo or repo per component... project management gets awkward if it's spread across multiple repos, and this app should be self-contained enough that a single repo will do the job well.

## Getting going

Right, so I first created a [new repo](https://github.com/seamonstr/todo) in GitHub - this will be for my source and my project management.  

Then, I cloned it to my local workstation.  Because I authenticate with GitHub using an SSH key, I used 
```
git clone ssh://git@github.com/seamonstr/todo.git
```

GitHub chose to have all of their usenames be 'git', for some reason... I assume it figures out which `git` you are by doing a lookup on the included signature; not sure why they didn't just use your actual GitHub username!

Then, I created the project in the GitHub repo by going to `Projects -> Create a project`, giving it a name that matches the app name (`todo`).

I chose `Basic kanban` to start with; I know that I can turn the automation on later if I want to.  GitHub Projects' automation is a bit blunt: it allows you to trigger the moving of a task between columns on a board based on commits that references the task.  In my experience, not many tasks on a board have just a single commit, so I want to try more stuff out before enabling that!

After hitting "Create", it took me to a basic board with "todo", "in progress" and "done" columns; the "ToDo" was populated with some sample stuff that I just deleted.

Fooling about with some issues (which is what they call tickets in GitHub Projects), I note that you can't group issues under each other, which makes doing epics hard. You can't even tag things which might help manage this.

You can  associate "Milestones" with an issue, which would work in much the same way as a tag - the [documentation for milestones](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/about-milestones) mentions that people use them to group issues every which way.  Fine.  We do that!

It looks as if GitHub is working on something more advanced in this area called "Github Issues" which allows nesting, tagging and so on.  It's still in Beta though - I've signed up for the beta and I'll do a post on that in the future if it comes through.

## Building the initial backlog

I've started with [my first epic](https://github.com/seamonstr/todo/milestone/1).  I'm taking care to express clearly the definitions of done, both from the user point of view but also from the technical point of view.

It's my experience that many teams start the project off with the idea of "we don't need automation to start with; let's add that when things get complicated".  However, at the start of the project is probably the only time that the team will have low enough pressure on delivery to make the required investment; also, if they develop a lot of code without automated testing and deployment in mind then they will have trouble retrofitting the deployment to it - it'll mean a lot of refactoring, and even then the CI/CD and testing will just never work as well as they'd like.

So, I'm starting off on that basis: an epic that produces an almost useless V1.0; not a minimum viable product, but a minimum deployable product.  However, the skeleton for all the facilities needed by a high-velocity team will be in place from the ground up.

Next step: add the initial backlog. As per the above, I'm going to start with the CI/CD:
1. [Story:](https://github.com/seamonstr/todo/issues/3) A static hello world page with no back-end behaviour and a deployment process for it.
1. [Story:](https://github.com/seamonstr/todo/issues/4) A URL hosted by AWS that can be flipped to new environments as they come on line - at this point we're live and repeatably deployable
1. [Spike:](https://github.com/seamonstr/todo/issues/7) A spike to investigate and design how the switchover to a newly deployed environment will work; otherwise the next story could end up with unnecessary rework.
1. [Story:](https://github.com/seamonstr/todo/issues/5) An infra-as-code setup to build the server environment along with tiny bit of back-end behaviour to show something non-static on the page: unit testing, integration testing and deployment. This one will include having the API publishable via a gateway thingy, with the IAC needed to achieve that.
1. [Story:](https://github.com/seamonstr/todo/issues/6) Implementation of the deploy-time switchover to the new environment - at this point the complete deployment system should be done.

So, I've created stub stories for all of the above in a minimal state that I'll flesh out as I go.  I've elaborated [the first](https://github.com/seamonstr/todo/issues/3) well enough to start with.

## Summary

Well, that's it - I've spent the afternoon on this now, having a good think about how to approach this. I've flushed out a lot more things to that I didn't think of before: how to build react apps, how to switch to a fresh environment, some others.  I'm ready to start on the first UI story when I next get a chance; I'll do a post then!